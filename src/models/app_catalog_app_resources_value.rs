/*
 * DSH Tenant Resource Management REST API
 *
 * Resource management API for DSH
 *
 * The version of the OpenAPI document: 1.6.6
 * 
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AppCatalogAppResourcesValue {
    /// How many CPUs this application needs (0.5 = 50% of 1 cpu)
    #[serde(rename = "cpus")]
    pub cpus: f32,
    /// Amount of memory your application needs in MB
    #[serde(rename = "mem")]
    pub mem: i32,
    /// Environment variables
    #[serde(rename = "env", skip_serializing_if = "Option::is_none")]
    pub env: Option<::std::collections::HashMap<String, String>>,
    /// Exposes ports of your application outside the platform
    #[serde(rename = "exposedPorts", skip_serializing_if = "Option::is_none")]
    pub exposed_ports: Option<::std::collections::HashMap<String, crate::models::PortMapping>>,
    #[serde(rename = "healthCheck", skip_serializing_if = "Option::is_none")]
    pub health_check: Option<Box<crate::models::HealthCheck>>,
    /// The container image to launch
    #[serde(rename = "image")]
    pub image: String,
    /// Number of instances that need to be spun up for this app
    #[serde(rename = "instances", skip_serializing_if = "Option::is_none")]
    pub instances: Option<i32>,
    /// If true, the platform will provision a secret token in the `DSH_SECRET_TOKEN` environment variable. This token can be exchanged for a client certificate that can be used for authentication to, amongst others, the Kafka brokers. 
    #[serde(rename = "needsToken", skip_serializing_if = "Option::is_none")]
    pub needs_token: Option<bool>,
    /// If true, the platform will ensure that there is always at most one instance of this application running at the same time. This impacts restart and upgrade behavior: A single-instance application will be terminated before a replacement is started, whereas an application that is not single-instance will remain running until its replacement has started and reports healthy. **Note** Applications that define volumes are always implicitly treated as single-instance, even if this flag is not set.
    #[serde(rename = "singleInstance", skip_serializing_if = "Option::is_none")]
    pub single_instance: Option<bool>,
    /// The userid:groupid combination used to start the application container.
    #[serde(rename = "user")]
    pub user: String,
    #[serde(rename = "metrics", skip_serializing_if = "Option::is_none")]
    pub metrics: Option<Box<crate::models::Metrics>>,
    /// The spread group - if any - to be used to ensure instances of one or more applications are not scheduled onto the same node.
    #[serde(rename = "spreadGroup", skip_serializing_if = "Option::is_none")]
    pub spread_group: Option<String>,
    #[serde(rename = "secrets", skip_serializing_if = "Option::is_none")]
    pub secrets: Option<Vec<crate::models::ApplicationSecret>>,
    /// names of scratch topics to which the application needs access.
    #[serde(rename = "topics", skip_serializing_if = "Option::is_none")]
    pub topics: Option<Vec<String>>,
    /// names of streams to which the application needs read access.
    #[serde(rename = "readableStreams", skip_serializing_if = "Option::is_none")]
    pub readable_streams: Option<Vec<String>>,
    /// names of streams to which the application needs write access.
    #[serde(rename = "writableStreams", skip_serializing_if = "Option::is_none")]
    pub writable_streams: Option<Vec<String>>,
    /// The volumes to be mounted in the container. The dictionary key is the mount point.
    #[serde(rename = "volumes", skip_serializing_if = "Option::is_none")]
    pub volumes: Option<::std::collections::HashMap<String, crate::models::ApplicationVolumes>>,
    #[serde(rename = "versioned")]
    pub versioned: bool,
    #[serde(rename = "encrypted")]
    pub encrypted: bool,
    #[serde(rename = "keySecret")]
    pub key_secret: String,
    #[serde(rename = "certChainSecret")]
    pub cert_chain_secret: String,
    #[serde(rename = "passphraseSecret", skip_serializing_if = "Option::is_none")]
    pub passphrase_secret: Option<String>,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "value")]
    pub value: String,
    #[serde(rename = "partitions")]
    pub partitions: i32,
    #[serde(rename = "replicationFactor")]
    pub replication_factor: i32,
    #[serde(rename = "kafkaProperties", skip_serializing_if = "Option::is_none")]
    pub kafka_properties: Option<::std::collections::HashMap<String, String>>,
    #[serde(rename = "sizeGiB")]
    pub size_gi_b: i32,
}

impl AppCatalogAppResourcesValue {
    pub fn new(cpus: f32, mem: i32, image: String, user: String, versioned: bool, encrypted: bool, key_secret: String, cert_chain_secret: String, name: String, value: String, partitions: i32, replication_factor: i32, size_gi_b: i32) -> AppCatalogAppResourcesValue {
        AppCatalogAppResourcesValue {
            cpus,
            mem,
            env: None,
            exposed_ports: None,
            health_check: None,
            image,
            instances: None,
            needs_token: None,
            single_instance: None,
            user,
            metrics: None,
            spread_group: None,
            secrets: None,
            topics: None,
            readable_streams: None,
            writable_streams: None,
            volumes: None,
            versioned,
            encrypted,
            key_secret,
            cert_chain_secret,
            passphrase_secret: None,
            name,
            value,
            partitions,
            replication_factor,
            kafka_properties: None,
            size_gi_b,
        }
    }
}


